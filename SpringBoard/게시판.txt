게시판.txt

- DataBase
	DB생성, 계정생성, 테이블 설계(ERD), 테이블 더미(가상)데이터 생성
	
- Spring MVC
	패키지 구조 설계, 개발환경 구성(빌드도구MAVEN), 컨트롤러, 서비스, DAO 구조 설계, 테스트 파일 생성

- 화면(view)
	뷰페이지 형태 설정
	
	
p83 커넥션풀 : DB 연결정보를 미리 생성 / 대여
	=> HikariCP - 스프링부트에서도 사용 
	
	
	
 * 프로젝트 패키지 구조 
 
  - 계층형 구조 : 각각의 객체 별로 따로 관리 (Controller, Service, Persistence)
     장점 : 프로젝트에 대한 이해도가 낮음 => 구조파악이 쉬움
     단점 : 클래스가 많아지면 복잡해짐, 모듈별로 분리가 어렵다.
     
     => 프로젝트의 복잡도가 낮고, 기능이 적은 프로젝트
     	 기능을 특정 기준을 바탕으로 구분하기 어려운 경우
  		 해당기능을 별도의 모듈로 분리할 가능성이 없는 경우
  
  - 도메인형 구조 : 도메인을 중심으로 따로관리 (Member.Controller, Member.Service, Member.Persistence)
     장점 : 모듈별로 구분이 쉬움(즉, 분리가 쉬움)
     단점 : 프로젝트에 대한 이해도가 낮으면, 구조파악이 힘듦
     		개인적인 성향에 따른 구분 (기준이 모호하다)
     		* 패키지간의 순환참조 가능성 있음
   
     => 프로젝트의 복잡도가 높고, 하나의 계층에 포함되는 클래스가 많은 경우
     	 기능별로 명확한 구분이 가능한 경우, 추후에 별도로 모듈 분리가 가능한 경우
     	 
     
  * 컨트롤러 설계
  - 공통적인 URI의 경로/ 각 기능별 URI의 경로 설계 (요구사항을 바탕으로 개발하기전에 주소를 미리 만들어야함)
  - 각 URI의 호출방법 (GET/POST)
  - 각 기능별 결과처리(뷰 출력, Redirect)
  - 예외 페이지
  
  => 컨트롤러를 구분하는 기준은 도메인객체(DB 테이블)
  
  
  공통 URI : /board   or   /boards
  호출방식 : GET - 사용자 정보입력, 조회, 출력
  			 POST - 데이터를 처리(쓰기,수정,삭제)
  			 	 
  기능별 URI : 
  			글쓰기(GET) : /board/register
  			글쓰기(POST) : /board/register
  			
  			리스트(GET) : /board/list
  			
  			본문읽기(GET) : /board/read?bno=?
  			
  			본문수정(GET) : /board/modify?bno=?
  			본문수정(POST) : /board/modify
  			
   			본문삭제(POST) : /board/remove?bno=?
   
   
   CTRL SHIFT F : 자동 들여쓰기
   
   * 의존객체 자동주입 : 스프링(컨테이너)가 자동으로 의존관계에 있는 객체를
  						사용하도록 의존성을 주입하는 것
  						
  	 - @Inject : Java에서 지원하는 어노테이션(특정 프레임워크 종속적이지 않다)  	   
  	   * 의존객체를 찾는 순서
  	   [타입] -> [@Qualifier] -> [이름] -> 실패  	   
  	   * 빌드도구(Maven/gradle)를 사용해서 라이브러리 의존성 추가필요
  	   * 멤버변수, setter, 생성자, 일반메서드 사용가능
  	 
  	 - @Autowired : Spring에서 지원하는 어노테이션  	   
  	   * 의존객체를 찾는 순서
  	   [타입] -> [이름] -> [@Qualifier] -> 실패
  	   * @Inject와 찾는순서만 다를뿐 동일하게 동작
  	   * <context:annotation-config/> 구문 설정필요
  	   * 멤버변수, setter, 생성자, 일반메서드 사용가능 
  	   
  	 - @Resource : Java에서 지원하는 어노테이션  	 
  	   * 의존객체를 찾는순서
  	     [이름] -> [타입] -> [@Qualifier] -> 실패
  	   * <context:annotation-config/> 구문 설정필요
  	   * 멤버변수, setter 사용가능
  	   
  	   
  	 ** @Qualifier : 객체를 주입 받아올때 동일한 객체(bean)가 있을경우 예외발생
  	  -> 특정 객체를 구분하기위한 이름(별명)
  	  
  	  	<bean id="dataSource1" 
  	  			class="com.zaxxer.hikari.HikariDataSource">
  	  			<qualifier value="ds1"/>
		</bean>
		
		<bean id="dataSource2" 
  	  			class="com.zaxxer.hikari.HikariDataSource">
  	  			<qualifier value="ds2"/>
		</bean>
		
		@Inject / @Autowired     @Qualifier("ds2")
		private DataSource ds;
  	 	
  	 	----------------------------------------------
  	 	최근에는 이렇게 사용 ↓ (딱히 상관은 없다.)
  	 	
  	 	// 생성자 주입
  	 	private DataSource ds;  	 	
  	 	
  	 	public Test( DataSource ds ){
  	 		this.ds = ds;  	 	
  	 	}
  	   
  	    
  	 
  	 
   
   
   
   
   
   
   
   